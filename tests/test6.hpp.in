#pragma once

#include <cassert>

#cmakedefine DYNOHOOK_TEST_NAME "@DYNOHOOK_TEST_NAME@"
#cmakedefine DYNOHOOK_TEST_CONV @DYNOHOOK_TEST_CONV@
#cmakedefine DYNOHOOK_TEST_OBJECT @DYNOHOOK_TEST_OBJECT@
#cmakedefine DYNOHOOK_TEST_HEADER "dynohook/conventions/@DYNOHOOK_TEST_HEADER@.hpp"
#cmakedefine DYNOHOOK_TEST_NAMESPACE @DYNOHOOK_TEST_NAMESPACE@

#include "dynohook/manager.hpp"
#include DYNOHOOK_TEST_HEADER

namespace DYNOHOOK_TEST_NAMESPACE {
    int g_iMyFuncCallCount = 0;
    int g_iPreMyFuncCallCount = 0;
    int g_iPostMyFuncCallCount = 0;

    using namespace dyno;

	class MyClass;
	MyClass* g_pMyClass = nullptr;

	class MyClass {
	public:
		MyClass() : m_iData{0} {}

        ASMJIT_NOINLINE int DYNOHOOK_TEST_CONV myFunc(int x, int y) {
			g_iMyFuncCallCount++;
			assert(this == g_pMyClass);
			assert(x == 3);
			assert(y == 10);

			int result = x + y;
			assert(result == 13);

			m_iData++;

			return result;
		}
	private:
		int m_iData;
	};

    ReturnAction PreMyFunc(HookType hookType, Hook& hook) {
        g_iPreMyFuncCallCount++;
        MyClass* pMyClass = hook.getArgument<MyClass *>(0);
		assert(pMyClass == g_pMyClass);

        int x = hook.getArgument<int>(1);
        assert(x == 3);

		int y = hook.getArgument<int>(2);
        assert(y == 10);

        return ReturnAction::Ignored;
    }

    ReturnAction PostMyFunc(HookType hookType, Hook& hook) {
        g_iPostMyFuncCallCount++;
        MyClass* pMyClass = hook.getArgument<MyClass *>(0);
		assert(pMyClass == g_pMyClass);

        int x = hook.getArgument<int>(1);
        assert(x == 3);

		int y = hook.getArgument<int>(2);
        assert(y == 10);

        int return_value = hook.getReturnValue<int>();
        assert(return_value == 13);

        hook.setReturnValue<int>(1337);

        return ReturnAction::Ignored;
    }

    void test() {
        HookManager& hookMngr = HookManager::Get();

		int (DYNOHOOK_TEST_CONV MyClass::*myFunc)(int, int) = &MyClass::myFunc;

        // Hook the function
        Hook* pHook = hookMngr.hook((void *&) myFunc, new DYNOHOOK_TEST_OBJECT({DATA_TYPE_POINTER, DATA_TYPE_INT, DATA_TYPE_INT}, DATA_TYPE_INT));

        // Add the callbacks
        pHook->addCallback(HookType::Pre, (HookHandler *) (void *) &PreMyFunc);
        pHook->addCallback(HookType::Post, (HookHandler *) (void *) &PostMyFunc);

		MyClass a;
		g_pMyClass = &a;

        // Call the function
        int ret = a.myFunc(3, 10);

        assert(g_iMyFuncCallCount == 1);
        assert(g_iPreMyFuncCallCount == 1);
        assert(g_iPostMyFuncCallCount == 1);
        assert(ret == 1337);

        hookMngr.unhookAll();

        printf("Test: \"%s\" was passed\n", DYNOHOOK_TEST_NAME);
    }
}